---
alwaysApply: false
---
# Figma MCP to React Converter Rule

## Scope
This rule applies when converting Figma designs to React components using MCP (Model Context Protocol).

## Purpose
Ensure consistent, modular, and maintainable React component architecture when converting designs from Figma.

---

## Step 1: Ingest Figma via MCP

### What to Extract
- Frame hierarchy and dimensions
- Component instances and their variants
- Text content and styles (font, size, weight, color)
- Colors and fills
- Auto Layout properties (direction, gap, padding, alignment)
- All image assets (product photos, icons, backgrounds)

### Capture Device Dimensions
- Record the root frame dimensions (e.g., 390x844 for iPhone 14)
- These become the base dimensions for the replica viewport
- All internal measurements are relative to these dimensions

---

## Step 2: Download Assets (CRITICAL)

### Rules
- Download ALL images from Figma MCP
- Never use placeholder URLs
- Save files with descriptive kebab-case names
- Organize assets by type (screens, components, icons)

### Asset Organization
```
Assets/
└── figma/
    ├── screens/           # Full screen reference images
    ├── components/        # Component images
    └── icons/             # Icons and UI elements
```

### Asset Naming Convention
- Use kebab-case: `item-image-1.png`, `action-icon.png`
- Include index for multiple similar items: `list-item-1.png`, `list-item-2.png`
- Be descriptive: `progress-indicator.png` not `image-5.png`

### Path References in Code
- Always use relative paths from HTML root: `Assets/figma/icons/icon-name.png`
- Never use absolute URLs or placeholder services
- Never embed base64 in code

---

## Step 3: Normalize into UI Objects

### UI Object Files
- Store in `src/ui-objects/`
- One file per screen: `src/ui-objects/screens/<ScreenName>.ui.json`
- One file per reusable component: `src/ui-objects/components/<ComponentName>.ui.json`

### Required UI Object Fields
```json
{
  "name": "ScreenName",
  "figmaNodeId": "123:456",
  "figmaFileKey": "abc123",
  "dimensions": { "width": 390, "height": 844 },
  "structure": {
    "fixedTop": ["SafeAreaTop", "StatusBar", "Header"],
    "scrollableContent": ["Section1", "Section2"],
    "fixedBottom": ["PrimaryCTA", "TabBar", "SafeAreaBottom"]
  }
}
```

### Structure Classification (CRITICAL)
Classify every element into one of three layers:
- **fixedTop** - Does NOT scroll (status bar, header)
- **scrollableContent** - Scrolls internally
- **fixedBottom** - Does NOT scroll (CTA, tab bar)

---

## Step 3.5: Define TypeScript Types (BEFORE Implementation)

### Rules
- Create TypeScript types BEFORE implementing components
- Extract interfaces from UI Object component props
- One type file per domain
- Store types in `src/types/`
- Use `.tsx` for components, `.ts` for non-JSX files

### Type Categories

| Category | Description | Example |
|----------|-------------|---------|
| Data Types | Entities from the domain | `Item`, `Entity`, `Record` |
| Props Types | Component input contracts | `ComponentNameProps` |
| State Types | Hook return types | `Use[Domain]Return` |
| Config Types | Static configuration | `TabConfig`, `OptionConfig` |

### Type File Structure
```
src/types/
├── [domain-a].ts      # Domain A entities
├── [domain-b].ts      # Domain B entities
├── ui.ts              # Common UI types
├── config.ts          # Configuration types
└── index.ts           # Barrel export
```

### Process
1. Analyze UI Object `components` array → extract Props interfaces
2. Analyze data shapes in design → extract entity interfaces
3. Analyze interactive elements → extract state/action types
4. Document optional vs required fields

### Type Template
```typescript
// src/types/[domain].ts

/** Entity representing a [domain] item */
export interface DomainItem {
  id: string;
  name: string;
  value: number;
  // ... fields extracted from Figma component
}

/** Props for [Component] */
export interface ComponentProps {
  item: DomainItem;
  onAction: (id: string) => void;
  isActive?: boolean;  // Optional props marked with ?
}

/** Return type for use[Domain] hook */
export interface UseDomainReturn {
  items: DomainItem[];
  total: number;
  addItem: (item: DomainItem) => void;
  removeItem: (id: string) => void;
}
```

### Examples

Good:
```typescript
// src/types/list.ts
export interface ListItem {
  id: string;
  image: string;
  title: string;
  subtitle: string;
  value: number;
  quantity: number;
}

export interface ListItemProps {
  item: ListItem;
  onIncrement: () => void;
  onDecrement: () => void;
}

// src/components/list/ListItem/ListItem.tsx
import { ListItemProps } from '../../../types';

export const ListItem: React.FC<ListItemProps> = ({ 
  item, 
  onIncrement, 
  onDecrement 
}) => {
  return <div>...</div>;
};
```

Bad:
```javascript
// No types - props are implicit
export const ListItem = ({ item, onIncrement, onDecrement }) => {
  // No type safety, no autocompletion, no documentation
  return <div>{item.tilte}</div>; // Typo not caught
};
```

---

## Step 4: Implement Layout Structure

### Rules
- Use `.tsx` extension for all React components
- Use `.ts` extension for hooks, utils, constants
- Import types from `src/types/`

### Project Structure (TypeScript)
```
src/
├── components/
│   ├── ui/
│   │   └── ComponentName/
│   │       ├── ComponentName.tsx    # .tsx for components
│   │       ├── ComponentName.css
│   │       └── index.ts             # .ts for exports
│   └── ...
├── hooks/
│   └── use[Domain].ts               # .ts for hooks
├── types/
│   └── [domain].ts                  # .ts for types
├── constants/
│   └── [domain].ts                  # .ts for constants
└── utils/
    └── [utility].ts                 # .ts for utils
```

### HTML/JSX Structure Template
```tsx
<DeviceFrame>
  {/* FIXED TOP */}
  <SafeAreaTop />
  <StatusBar />
  <Header />
  
  {/* SCROLLABLE CONTENT */}
  <div className="content-area">
    <Section1 />
    <Section2 />
  </div>
  
  {/* FIXED BOTTOM */}
  <PrimaryCTA />
  <TabBar />
  <SafeAreaBottom />
</DeviceFrame>
```

### CSS Structure
```css
.app-viewport {
  width: 428px;
  height: 926px;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.content-area {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
  -webkit-overflow-scrolling: touch;
}
```

---

## Step 4.5: Apply Design Tokens (Design System)

### Purpose
Translate design values extracted from Figma into reusable tokens and enforce their use across all component styles.

### Rules
- Export design tokens from normalization as a stable source file (JSON) in `src/design/tokens.json`
- Generate a single CSS custom properties file in `src/styles/tokens.css`
- Import tokens once globally (e.g., in `src/styles/global.css`) and never re-declare tokens inside component CSS
- Use `var(--token-name)` in component CSS for colors, spacing, radii, typography, shadows, and motion
- Prefer **semantic tokens** over raw values (e.g., `--color-surface` instead of `--color-white`)
- Keep token names **project-agnostic** and **domain-agnostic** (never encode screen names, product names, or feature names)
- Keep tokens **component-agnostic** (avoid `--header-title-color`; prefer `--color-text-primary`, `--font-size-lg`)
- Allow a small set of raw/base tokens only when necessary (e.g., `--space-4`, `--radius-12`) and build semantic tokens on top
- Never hardcode hex colors, pixel spacing, radii, font sizes/weights in component CSS when a token exists

### Output Files
```
src/
├── design/
│   └── tokens.json         # Source of truth for extracted design values
└── styles/
    ├── tokens.css          # :root { --tokens... }
    └── global.css          # imports tokens.css
```

### Token Naming (Recommended)
- Colors: `--color-bg`, `--color-surface`, `--color-border`, `--color-separator`, `--color-text-primary`, `--color-text-secondary`, `--color-accent`
- Spacing: `--space-xs`, `--space-sm`, `--space-md`, `--space-lg`, `--space-xl`
- Radii: `--radius-sm`, `--radius-md`, `--radius-lg`
- Typography: `--font-family`, `--font-size-sm|md|lg`, `--font-weight-regular|medium|semibold|bold`
- Shadows: `--shadow-sm|md|lg`
- Motion: `--transition-fast|normal|slow`

### Examples

Good:
```css
/* src/styles/global.css */
@import './tokens.css';

.card {
  background: var(--color-surface);
  color: var(--color-text-primary);
  border-radius: var(--radius-lg);
  padding: var(--space-lg);
  box-shadow: var(--shadow-md);
}
```

Bad:
```css
/* Tokens re-declared in component CSS, plus hardcoded values */
.card {
  --color-surface: #ffffff;
  background: #ffffff;
  border-radius: 16px;
  padding: 20px;
}
```

---

## Step 5: Modular Component Architecture

### Rules
- Create one folder per component containing `.tsx`, `.css`, and `index.ts`
- Organize components by role: ui, layout, feature-specific
- Use barrel exports (`index.ts`) for clean imports
- Extract constants to dedicated files
- Extract utilities to dedicated files
- Screens must only compose components, not define them inline

### Project Structure
```
src/
├── components/
│   ├── ui/                    # Atomic UI primitives
│   │   ├── Badge/
│   │   │   ├── Badge.tsx
│   │   │   ├── Badge.css
│   │   │   └── index.ts
│   │   ├── Toggle/
│   │   ├── ProgressBar/
│   │   └── index.ts           # Barrel export
│   │
│   ├── layout/                # Structural components
│   │   ├── DeviceFrame/
│   │   ├── StatusBar/
│   │   ├── Header/
│   │   ├── TabBar/
│   │   ├── SafeArea/
│   │   └── index.ts
│   │
│   └── [feature]/             # Feature-specific components
│       ├── FeatureComponent1/
│       ├── FeatureComponent2/
│       └── index.ts
│
├── screens/                   # Screen compositions
│   └── ScreenName/
│       ├── ScreenName.tsx
│       ├── ScreenName.css
│       └── index.ts
│
├── hooks/                     # Custom hooks
│   ├── use[DomainA].ts
│   ├── use[DomainB].ts
│   └── index.ts
│
├── types/                     # TypeScript types
│   ├── [domain].ts
│   └── index.ts
│
├── constants/                 # Business constants
│   └── [domain].ts
│
├── utils/                     # Utility functions
│   ├── [utility].ts
│   └── index.ts
│
└── styles/                    # Global styles
    └── global.css
```

### Component Classification

**UI Primitives (`ui/`):**
- Components without business logic
- Reusable across any project
- Examples: Badge, Toggle, Button, Input, ProgressBar

**Layout Components (`layout/`):**
- Screen structure components
- Device frame and safe areas
- Navigation elements
- Examples: DeviceFrame, StatusBar, Header, TabBar, SafeArea

**Feature Components (`[feature]/`):**
- Components with business context
- Named by domain
- Examples: ItemCard, ListRow, ActionPanel

### Barrel Export Pattern
```typescript
// src/components/ui/index.ts
export { Badge } from './Badge';
export { Toggle } from './Toggle';
export { ProgressBar } from './ProgressBar';
```

### Component Folder Structure
```
ComponentName/
├── ComponentName.tsx    # Component logic and markup
├── ComponentName.css    # Component-scoped styles
└── index.ts             # Re-export for clean imports
```

### Examples

Good:
```
src/components/
├── ui/
│   ├── Badge/
│   │   ├── Badge.tsx
│   │   ├── Badge.css
│   │   └── index.ts
│   └── index.ts
├── layout/
│   ├── Header/
│   │   ├── Header.tsx
│   │   ├── Header.css
│   │   └── index.ts
│   └── index.ts
└── [feature]/
    ├── FeatureItem/
    └── index.ts
```

```tsx
// Clean imports via barrel exports
import { Badge, Toggle } from '../components/ui';
import { Header, TabBar } from '../components/layout';
import { FeatureItem } from '../components/[feature]';
```

Bad:
```tsx
// All components in single file - monolithic
const ScreenComponent = () => {
  const Badge = () => <span>...</span>;
  const Header = () => <header>...</header>;
  const FeatureItem = () => <div>...</div>;
  // 500+ lines of inline components
};
```

```
// Flat structure without organization
src/components/
├── Badge.tsx
├── Header.tsx
├── FeatureItem.tsx
├── Toggle.tsx
├── TabBar.tsx
└── ... 20 more files
```

---

## Quality Checklist

Before considering a screen complete:

- [ ] All images downloaded to `Assets/figma/`
- [ ] All image paths reference local files
- [ ] TypeScript types defined in `src/types/`
- [ ] Components use `.tsx` extension
- [ ] Hooks/utils/constants use `.ts` extension
- [ ] Components organized by role (ui/layout/feature)
- [ ] Each component has own folder with `.tsx`, `.css`, `index.ts`
- [ ] Barrel exports configured for each category
- [ ] Constants extracted to `src/constants/`
- [ ] Utilities extracted to `src/utils/`
- [ ] Screen only composes components
- [ ] Three-layer architecture implemented
- [ ] Design tokens exported to `src/design/tokens.json`
- [ ] `src/styles/tokens.css` exists and is globally imported once
- [ ] Component CSS uses `var(--token)` instead of hardcoded values (where tokens exist)
- [ ] Touch targets minimum 44x44px

---

## Examples

### Asset Download

Good:
```typescript
const imageData = await mcp.getAsset(nodeId);
await fs.writeFile('Assets/figma/components/item-image-1.png', imageData);

// Reference in code
<img src="Assets/figma/components/item-image-1.png" alt="item" />
```

Bad:
```typescript
<img src="https://via.placeholder.com/80x80" alt="item" />
<img src="http://localhost:3845/assets/temp-xyz" alt="item" />
```

### Structure Classification

Good:
```json
{
  "structure": {
    "fixedTop": ["SafeAreaTop", "StatusBar", "Header"],
    "scrollableContent": ["Section1", "Section2"],
    "fixedBottom": ["PrimaryCTA", "TabBar", "SafeAreaBottom"]
  }
}
```

Bad:
```json
{
  "components": ["Header", "Section1", "TabBar"]
}
```

### TypeScript Component

Good:
```tsx
// types defined first
interface ItemProps {
  id: string;
  title: string;
  value: number;
  onSelect: (id: string) => void;
}

// component with explicit types
export const Item: React.FC<ItemProps> = ({ id, title, value, onSelect }) => {
  return (
    <div onClick={() => onSelect(id)}>
      <span>{title}</span>
      <span>{value}</span>
    </div>
  );
};
```

Bad:
```jsx
// no types, implicit any
export const Item = ({ id, title, value, onSelect }) => {
  return (
    <div onClick={() => onSelect(id)}>
      <span>{title}</span>
      <span>{valeu}</span>  {/* typo not caught */}
    </div>
  );
};
```

### Token Usage

Good:
```css
.card {
  background: var(--color-surface);
  border-radius: var(--radius-lg);
  padding: var(--space-lg);
}
```

Bad:
```css
.card {
  background: white;
  border-radius: 16px;
  padding: 20px;
}
```

---

## Constraints
- Never use placeholder URLs for assets
- Never embed base64 assets in code
- Never skip the normalization step
- Never skip the type definition step
- Never use `.jsx`/`.js` extensions (use `.tsx`/`.ts`)
- Never put fixed elements inside scrollable content
- Never define components inline within screens
- Never create flat component structures without categorization
