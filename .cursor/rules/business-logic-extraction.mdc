---
alwaysApply: false
---
# Business Logic Extraction Rule

## Scope
This rule applies when converting Figma designs to React applications and extracting business logic into reusable hooks.

## Purpose
Ensure business logic is properly identified, extracted, and organized into custom hooks during the design-to-code conversion process. Separating business logic from UI components improves testability, reusability, and maintainability.

---

## Identifying Business Logic in Figma

### Rules
- Analyze component names for action verbs (Add, Remove, Update, Calculate, Toggle)
- Look for numeric displays that depend on other values (totals, counts, percentages)
- Identify conditional UI states (enabled/disabled, visible/hidden, active/inactive)
- Find progress indicators that track toward thresholds
- Note interactive elements that modify shared state

### Business Logic Indicators in Component Names

| Component Pattern | Indicates |
|-------------------|-----------|
| `*Controller`, `*Stepper` | State management + increment/decrement actions |
| `*Summary`, `*Total` | Calculations based on aggregated data |
| `*Toggle`, `*Switch` | Boolean state + conditional logic |
| `*Button` with dynamic label | Action trigger + computed display value |
| `*Progress`, `*Bar` | Percentage calculation toward threshold |
| `*Badge` with count | Derived count from collection |

---

## Hook Classification

### Rules
- Create one hook per domain responsibility
- Name hooks with `use` prefix followed by domain noun
- Separate state hooks from calculation hooks
- Compose hooks in screen components, not inside other hooks

### Hook Categories

**State Hooks** (manage mutable data):
- `use[Collection]` — items collection, CRUD operations
- `use[Entity]` — single entity state management
- `useForm` — form fields, validation state

**Calculation Hooks** (derive values from inputs):
- `use[Domain]Calculation` — derived values based on inputs
- `use[Threshold]Progress` — progress toward a goal
- `useTotals` — aggregated sums and counts

**Action Hooks** (coordinate complex operations):
- `use[Action]` — combines data, triggers side effects
- `use[Feature]` — orchestrates multiple operations

---

## Hook Structure Pattern

### Rules
- Accept dependencies as parameters
- Return object with state values and action functions
- Use `useMemo` for derived calculations
- Use `useCallback` for action functions
- Export named function and default export

### Template
```javascript
import { useState, useMemo, useCallback } from 'react';

/**
 * Hook for [domain] management
 * @param {Type} dependency - Description
 * @returns {Object} State and actions
 */
export const use[Domain] = (dependency) => {
  // State
  const [state, setState] = useState(initialValue);

  // Derived values (calculations)
  const derivedValue = useMemo(
    () => /* calculation based on state/dependency */,
    [state, dependency]
  );

  // Actions
  const action = useCallback((params) => {
    setState(prev => /* mutation logic */);
  }, []);

  return {
    // State values
    state,
    derivedValue,
    // Actions
    action
  };
};

export default use[Domain];
```

---

## Extraction Process

### Rules
- Step 1: Identify all state variables in the screen component
- Step 2: Group related state by domain
- Step 3: Identify calculations that depend on state
- Step 4: Identify actions that modify state
- Step 5: Create hook per domain with its state, calculations, and actions
- Step 6: Replace inline logic in component with hook calls

### Domain Grouping Template
```
[Domain A]:
- State: [state variables]
- Derived: [computed values]
- Actions: [mutation functions]

[Domain B]:
- Input: [dependencies from other domains]
- Derived: [computed values]
- Actions: [none if pure calculations]
```

---

## File Organization

### Rules
- Store all hooks in `src/hooks/` directory
- Create barrel export in `src/hooks/index.js`
- One hook per file
- Name file same as hook function

### Structure
```
src/hooks/
├── use[DomainA].js
├── use[DomainB].js
├── use[DomainC].js
└── index.js          # Barrel export
```

---

## Examples

### Example: Identifying Business Logic from Figma

This example demonstrates how to extract logic from a delivery summary component.

Good:
```
Figma Component: "Delivery Summary"
Visual elements:
- Text: "До бесплатной доставки 1953₽"
- Progress bar at ~20%
- Conditional text: "Бесплатно" when threshold reached

Extracted business logic:
- Constant: FREE_THRESHOLD (numeric value from design)
- Calculation: remaining = threshold - currentValue
- Calculation: progress = (currentValue / threshold) * 100
- Condition: isFree = currentValue >= threshold

→ Create: useThresholdProgress(currentValue, threshold)
```

Bad:
```
Figma Component: "Delivery Summary"

Approach: Hard-code "1953₽" as static text in JSX
Result: No business logic extracted, UI not reactive to state changes
```

### Example: Hook Implementation Pattern

Good:
```javascript
// Generic threshold progress hook
export const useThresholdProgress = (currentValue, threshold) => {
  const remaining = useMemo(
    () => Math.max(0, threshold - currentValue),
    [currentValue, threshold]
  );

  const progressPercent = useMemo(
    () => Math.min(100, (currentValue / threshold) * 100),
    [currentValue, threshold]
  );

  const isComplete = currentValue >= threshold;

  return { remaining, progressPercent, isComplete };
};

// Usage in screen component
const progress = useThresholdProgress(subtotal, FREE_DELIVERY_THRESHOLD);
```

Bad:
```javascript
// All logic inline in component
const ScreenComponent = () => {
  const remaining = Math.max(0, 2551 - subtotal);
  const progress = (subtotal / 2551) * 100;
  const isFree = subtotal >= 2551;
  // Magic numbers, untestable, not reusable
};
```

### Example: Hook Composition

Good:
```javascript
// Screen composes independent hooks
const ScreenComponent = () => {
  const collection = useCollection(initialItems);
  const calculations = useCalculations(collection.total);
  const conditional = useConditional(collection.total);
  const actions = useActions({
    total: collection.total,
    modifier: conditional.amount
  });

  return <UI data={...} />;
};
```

Bad:
```javascript
// Hook calls another hook internally - hidden dependency
const useActions = () => {
  const collection = useCollection();  // BAD: hook inside hook
  const calculations = useCalculations(); // BAD: hidden dependency
};
```

### Example: Constants Extraction

Good:
```javascript
// src/constants/[domain].js
export const THRESHOLD_VALUE = 2551;
export const BASE_AMOUNT = 249;
export const MIN_REQUIREMENT = 2500;

// Hook imports constants
import { THRESHOLD_VALUE, BASE_AMOUNT } from '../constants/[domain]';

export const useDomainLogic = (input) => {
  const result = input >= THRESHOLD_VALUE ? 0 : BASE_AMOUNT;
  return { result };
};
```

Bad:
```javascript
// Magic numbers without explanation
const useDomainLogic = (input) => {
  const result = input >= 2551 ? 0 : 249; // What do these mean?
};
```

---

## UI Object Extension for Business Logic

### Rules
- Add `businessLogic` section to UI object files during normalization
- Document identified calculations and thresholds
- List required hooks for the screen
- Mark unknown logic as TODO

### Extended UI Object Format
```json
{
  "name": "ScreenName",
  "structure": {...},
  "businessLogic": {
    "hooks": [
      "use[DomainA]",
      "use[DomainB]",
      "use[DomainC]"
    ],
    "constants": {
      "CONSTANT_NAME_1": "value (extracted from design)",
      "CONSTANT_NAME_2": "value (extracted from design)"
    },
    "calculations": [
      "total = sum of (item.value * item.quantity)",
      "result = input >= THRESHOLD ? valueA : valueB"
    ],
    "unknownLogic": [
      "TODO: How is [feature] calculated?",
      "TODO: What triggers [action]?"
    ]
  }
}
```

---

## Constraints
- Never put all business logic in screen components
- Never hard-code business constants in components or hooks
- Never call hooks inside other hooks (compose at screen level)
- Never skip the identification step before implementation
- Never implement calculations without extracting constants first
- Always document unknown business logic as TODO
